{"version":3,"file":"predictor.js","sourceRoot":"","sources":["../../../src/lib/predictor.ts"],"names":[],"mappings":";;AAAA,gEAAkE;AAQlE;IAGE;QACE,IAAI,CAAC,IAAI,GAAG,CAAC,CAAA;IACf,CAAC;IASD,6BAAS,GAAT,UAAW,KAAa,EAAE,MAAc;QACtC,IAAI,CAAC,IAAI,IAAI,MAAM,CAAA;IACrB,CAAC;IAWD,gCAAY,GAAZ,UAAc,KAAsB;QAClC,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAG3B,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAA;YAC/B,MAAM,CAAA;QACR,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAA;QAC5C,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAA;QAC1C,CAAC;QAED,IAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QACtD,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAA;IACjC,CAAC;IAUD,oCAAgB,GAAhB,UAAkB,MAAc,EAAE,MAAc;QAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IACnB,CAAC;IASD,uCAAmB,GAAnB,UAAqB,MAAc;QACjC,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;IACxC,CAAC;IAOD,yBAAK,GAAL,UAAO,KAAa;QAClB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,MAAM,CAAA;IAC3B,CAAC;IAOD,wBAAI,GAAJ,UAAM,KAAa;QACjB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAA;IACpB,CAAC;IAOD,2BAAO,GAAP;QACE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAA;IAClB,CAAC;IAEO,sCAAkB,GAA1B,UAA4B,MAAc;QAExC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QAGZ,EAAE,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC;YACjB,IAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;YAC/D,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;QAC3B,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IACnB,CAAC;IACH,gBAAC;AAAD,CAAC,AAzGD,IAyGC;AAUD,CAAC;AAAA,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,KAAK;IAC1B,SAAS,CAAC,SAAS,CAAC,WAAW,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,UAAU,KAAa;QACpE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;IACrC,CAAC,CAAA;AACH,CAAC,CAAC,CAAA;AAEF,kBAAe,SAAS,CAAA","sourcesContent":["import isInteger = require('core-js/library/fn/number/is-integer')\n\n/**\n * Writable stream which tracks the amount of data written.\n *\n * This class acts as a writable stream, but only does the minimum amount of\n * work necessary to count/predict the output size.\n */\nclass Predictor {\n  size: number\n\n  constructor () {\n    this.size = 0\n  }\n\n  /**\n   * Add the size of a fixed-length integer to the predicted size.\n   *\n   * @param {number} value Value of integer. Irrelevant here, but included in\n   *                       order to have the same interface as the Writer.\n   * @param {number} length Size of integer in bytes.\n   */\n  writeUInt (value: number, length: number) {\n    this.size += length\n  }\n\n  /**\n   * Calculate the size of a variable-length integer.\n   *\n   * A VARUINT is a variable length integer encoded as base128 where the highest\n   * bit indicates that another byte is following. The first byte contains the\n   * seven least significant bits of the number represented.\n   *\n   * @param {number} value Integer to be encoded\n   */\n  writeVarUInt (value: number | Buffer) {\n    if (Buffer.isBuffer(value)) {\n      // If the integer was already passed as a buffer, we can just treat it as\n      // an octet string.\n      this.writeVarOctetString(value)\n      return\n    } else if (!isInteger(value)) {\n      throw new Error('UInt must be an integer')\n    } else if (value < 0) {\n      throw new Error('UInt must be positive')\n    }\n\n    const length = Math.ceil(value.toString(2).length / 8)\n    this.skipVarOctetString(length)\n  }\n\n  /**\n   * Skip bytes for a fixed-length octet string.\n   *\n   * Just an alias for skip. Included to provide consistency with Writer.\n   *\n   * @param {Buffer} buffer Data to write.\n   * @param {Number} length Length of data according to the format.\n   */\n  writeOctetString (buffer: Buffer, length: number) {\n    this.skip(length)\n  }\n\n  /**\n   * Calculate the size of a variable-length octet string.\n   *\n   * A variable-length octet string is a length-prefixed set of arbitrary bytes.\n   *\n   * @param {Buffer} value Contents of the octet string.\n   */\n  writeVarOctetString (buffer: Buffer) {\n    this.skipVarOctetString(buffer.length)\n  }\n\n  /**\n   * Pretend to write a series of bytes.\n   *\n   * @param {Buffer} Bytes to write.\n   */\n  write (bytes: Buffer) {\n    this.size += bytes.length\n  }\n\n  /**\n   * Add this many bytes to the predicted size.\n   *\n   * @param {Number} Number of bytes to pretend to write.\n   */\n  skip (bytes: number) {\n    this.size += bytes\n  }\n\n  /**\n   * Get the size the buffer would have if this was a real writer.\n   *\n   * @return {Number} Size in bytes.\n   */\n  getSize () {\n    return this.size\n  }\n\n  private skipVarOctetString (length: number) {\n    // Skip initial byte\n    this.skip(1)\n\n    // Skip separate length field if there is one\n    if (length > 127) {\n      const lengthOfLength = Math.ceil(length.toString(2).length / 8)\n      this.skip(lengthOfLength)\n    }\n\n    this.skip(length)\n  }\n}\n\ninterface Predictor {\n  writeUInt8 (value: number): undefined\n  writeUInt16 (value: number): undefined\n  writeUInt32 (value: number): undefined\n  writeUInt64 (value: number): undefined\n}\n\n// Create writeUInt{8,16,32,64} shortcuts\n;[1, 2, 4, 8].forEach((bytes) => {\n  Predictor.prototype['writeUInt' + bytes * 8] = function (value: number) {\n    return this.writeUInt(value, bytes)\n  }\n})\n\nexport default Predictor\n"]}